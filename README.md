# Echellogram-to-Spectrum

Code to convert an echellogram (photo) to a spectrum. Meant to replace Sophi nXt software in case of misaligned spectrometer image.

https://github.com/Tshepajev/Echellogram-to-spectrum

**Licence:** MIT – do whatever you want with the script. It's nice if you mention me if your work is largely based on my script, but I won't come looking for you if you don't.

---

## Overview

Sophi nXt operates as follows: 
1. Spectrometer/camera is calibrated prior to experiments (e.g. with Hg calibration lamp). The software automatically finds the strong Hg lines and adjusts a pre-saved internal calibration matrix, which describes which pixels on the camera photos to use for different wavelengths on the spectra. This calibration determines the horizontal and vertical shift of the pre-saved internal matrix data.
2. During experiments, Sophi nXt operates the spectrometer and the camera and the echellograms (photos of spectrometer output) are saved.
3. The spectrum is compiled from the echellogram and saved for analysis. The pre-determined internal Sophi's calibration matrix is used with calibration data from step 1 (vertical and horizontal shifts). Each diffraction order represents a horizontal line on the echellogram, different diffraction orders are situated on different rows of the echellogram. If the spectrometer output has shifted (e.g. thermal expansion during experiments) then the pre-determined horizontal and vertical shift are wrong and the spectrum is compiled incorrectly (has ghost lines, inaccurate intensities and inaccurate wavelengths).

This repository contains two programs (**"Calibrator"** and **"Processor"**). The **Calibrator** is for step 1: finding the internal calibration matrix and horizontal and vertical shifts. The **Processor** is for step 3: for batch-compiling spectra from echellograms with the calibration data from the **Calibrator**. These programs are meant to replace Sophi nXt software in steps 1 and 3 in case you need to recompile spectra from the echellograms due to misalignment of the original spectra. That is, if you have the echellograms from Sophi nXt but the spectra compiled from those photos are misaligned (ghost lines, wrong intensities and wrong wavelengths) then my programs allow to fix that issue.

---

## Branch Structure

- **Main Branch**: Contains code meant for sharing and downloading.  
- **Development Branch**: For my personal use, lazy version management, and ability to roll back changes. It has the latest features but might also have broken code.

If something is broken (bug), a temporary fix is to (potentially save your data and) restart the program (exit and restart).  
You can always roll back to a previous GitHub file version and compare changes. If you find bugs, please let me know!

PS. Antivirus hunts the compiled `.exe`s like crazy and that's why these are only under releases (right side of the webpage). These are compiled directly from the source code using "PyInstaller --onefile script.py" This means all dependencies are included inside the executable. You can always just use the source code.

---

## Repository Contents

There are different folders in the repository:

- **Code Folder**  
  Contains the main code:
  - **`_Echellogram-to-spectrum-calibration.py`**: This is the main program, referred to as **"Calibrator"**. It has a graphical user interface (GUI) and generates calibration data to process an echellogram to spectrum. You can create and modify the diffraction order matrix (recreate Sophi nXt internal matrix) and find horizontal and vertical shift. You can also save the single spectrum but batch-processing spectra is left for **Processor**.
  - **`_Echellogram-to-spectrum-processing.py`**: Referred to as **"Processor"**, it doesn’t have a GUI and is essentially a simplified version of the **Calibrator**. **Processor** inputs the calibration file generated by **Calibrator** and batch-processes an entire folder of echellograms at once. The echellograms are compiled into spectra using the same process as **Calibrator**.
  - These files have corresponding `.exe` files published under "Releases" (on the right in the Github repository). Those, however, trigger my antivirus every time I create or even move them (quite annoying). I'm guessing same thing will happen for you.

- **Example Input Files**  
  Contains sample files to test the programs:
  - **`_Vertical_points.csv`**: Input bounds data for **Calibrator v2** (not used in v3).
  - **`_Calibration_data.json`**: Calibration data for both **Calibrator** and **Processor**. You can use this as a starting point.

- **Helper Files**  
  Contains files to help analyze the Sophi nXt spectra and echellograms. The basis for these programs comes from here: https://gitlab.com/ltb_berlin/ltb_files.
  - **Batch convert aryx.py** (or respective `.exe`): Batch-processes all `.aryx` files in the folder where the code is executed (where the .py file is), outputting respective `.txt` files. The output file is the same as if you exported the `.aryx` file in Sophi nXt. The data contains wavelengths and intensities separated with a semicolon ";".
  - **Batch convert aryx recursive.py** (or respective `.exe`): Same as above, but recursively checks all sub-folders. Useful for e.g. converting an entire week’s spectra. **Warning**: Running in a high-level folder will check everything on your PC.
  - **Extract aryx.py**: Reads an `.aryx` file and exports the data to `.csv` files, including wavelengths, intensities, order numbers, and metadata (at the end of the file). It also extracts **aif** data (orders info) from `.aryx` that can be used to create `"_Vertical_points.csv"` for **Calibrator v2**.
  - **Extract tif.py**: Reads a Sophi nXt `.tif` file and exports the data to `.csv` files. This includes the echellogram (2D intensity matrix) and metadata.

---

## Instructions

### Creating Calibration Data

1. Place the **Calibrator** (.py or .exe) in the folder with the echellograms. If you run into filepath errors then you can either insert the actual filepath into the GUI field `Directory path` or manually use the `working_path` variable in the beginning of **Calibrator** code (line 45). If you use the latter then you need to use the code directly (not `.exe`s).
2. **Optional** (recommended): Place the previous correct calibration data `_Calibration_data*.json` file (* can be anything) in the same folder with the echellograms.
    - **Optional** (strongly recommended): Back up the calibration data before running **Calibrator** if you haven't renamed the calibration data (since it will overwrite the file when saving calibration data).
	- **Warning!** Make sure there is max one calibration data file or the program will choose a random one.
3. For **Calibrator v2** (skip for v3):
    - Compile the bounds data **`_Vertical_points*.csv`**  (* can be anything).
    - You can use **`Extract aryx.py`** from helper files or use Sophi nXt tooltips to compile this data in Excel. The first row must be headers (gets ignored), and the columns must be:  
      `Order nr`, `Start px`, `End px`, `Start wavelength (nm)`, `End wavelength (nm)`, `Middle px` (optional), `Middle wavelength (nm)` (optional).  
      The px → wavelength conversion is quadratic, but close to linear, so the middle point is strongly recommended.
    - Place the compiled **`_Vertical_points*.csv`** in the same folder as the echellograms.
	- **Warning!** Make sure there is max one bounds data file or the program will choose a random one.
4. Run **Calibrator**.
5. Create or fine-tune the calibration data using the GUI. The most important adjustments are **vertical** and **horizontal shifts**, the **first order number**, and the order **curve shape**.  
    Consider the following:
    - Does the curve align with the bright line on the echellogram? Also, are the ghost lines approximately the same intensity on both sides of the main line? (**curve shape** and **vertical shift**)
    - Is a given wavelength in the correct order, as in Sophi nXt? (**first order number**)
    - Does the wavelength match with Sophi nXt? (**first order number** and **horizontal shift**, a little bit of **curve shape**)
	- The optimal way of doing things is to have the bounds data as large as possible (starts from smallest order nr in JET campaign experiments) and the corresponding amount of orders drawn. The program excludes the orders that are out of bounds by default.
    - **Optional** (strongly recommended): Check multiple different samples for curve alignment (**curve shape**). The alignment difference between samples should only be **the shifts**.
6. Save the calibration data (this will overwrite the existing file, so **make backups!**).
7. **Optional**: Output other data like the compiled spectrum for checking.
8. **Optional** (recommended): Clean up by removing files from the folder unless it's a dedicated test folder.

### Processing Echellograms

1. Place the **Processor** (.py or .exe) in the folder with the echellograms. If you run into filepath errors then you can manually use the `working_path` variable in the beginning of **Processor** code (line 29). If you use the latter then you need to use the code directly (not `.exe`s).
2. Place the correct calibration data `.json` file (from **Calibrator**) in the same folder.
3. **Optional** **(!!) broken and currently unused (!!)**: Place spectral sensitivity data **`_Spectra_multipliers*.csv`** in the same folder (* can be anything). The Processor will then interpolate-extrapolate wavelengths, and the intensity of each pixel of the spectrum will be multiplied by the corresponding (interpolated) multiplier. The file must contain headers row (gets ignored) and the following columns: `wavelengths (nm)`, `multipliers`.
	- **Warning!** Make sure there is max one multipliers data file or the program will choose a random one.
4. Run the **Processor**.
5. **Optional** (**strongly** recommended): Also process the spectral sensitivity measurement echellogram with the same calibration data `.json` file. E.g. if you made an experiment where you measured the W lamp calibration lamp output to compare with datasheet output to calculate the spectral sensitivity, then the spectrum needs to be compiled with the current `.json`file. If the spectral sensitivity isn't calculated from the spectrum compiled with the current calibration file (e.g. you use original Sophi-compiled spectrum), then it won't be for the same situation and shouldn't be used. If you use step 3 then step 5 is especially relevant (process W lamp spectrum first and then batch-process everything else).
6. **Optional** (recommended): Clean up by removing the **Processor** and calibration files from the folder.

---

## How Calibrator Works

**Important:**  When using **Calibrator**, back up **`_Calibration_data.json`**, as it might get overwritten.

This README provides general concepts, but to get the specifics, you need to check the code and its comments. The best tool to see how a variable is used is `Ctrl + F`. \
You can always run the program in a Python IDE (e.g., Spyder or Thonny) and modify it according to your needs. For example, you can modify global variables like `working_path` and `series_filename` at the start of the `.py` file.

**The Point of the GUI**: The user can modify the diffraction order curves (either move the points or shift all orders) and add/delete them. Finally, the user must press **"Save calibration data"** which will overwrite **`_Calibration_data.json`**. Restarting the Calibrator would now take the new file as input.


##### **GUI Features:**
- **Left Pane**: Contains buttons and inputs to help use the program.
- **Top Right**: Displays the echellogram with orders drawn.  
    - **Red**: Default order.
    - **White**: Selected order.
    - **Gray**: Order too close to the image edge.
    - **Black crosses**: Pixel bounds.
    - **Orange circles**: Three points used to define the quadratic curve of a diffraction order.
- **Bottom Right**: Displays the resulting spectrum.  
- The toolbars below the plots help to navigate the view. Right-click drag (horizontally and vertically) with the move tool can zoom towards a point.


##### **"Dangerous" Buttons in the GUI:**

- **Save calibration data**: Overwrites the calibration data (used also as input during next restart).
- **Output stuff**: Overwrites previously output files if not backed up. 

Otherwise don't be afraid to press the buttons and test what they do.

##### **General description:**

If run with the default parameters, then **Calibrator** checks where the script that was run is located. This folder will be the root folder for the program.\
**Calibrator** will check for echellograms in the folder and will take a random sample automatically. E.g. if you have sample 24 series (`sample_24_0001.tif`, `sample_24_0002.tif` etc.) and sample 492 series in the same folder then one of those series will be automatically chosen.\
**Calibrator** will average first 20 echellograms of that sample series and average these.


**Input data:**
Then **Calibrator** will read `"_Calibration_data*.json"` (* can be anything) if it exists in the folder. If there are multiple such files in the folder then a random one is chosen, so it's important to keep the folder tidy. E.g. you can rename a file to `"_xCalibration_..."` for it to not be read.
According to the data in `"_Calibration_data.json"`, **Calibrator** draws diffraction orders on the echellogram (quadratic fn with 3 points each). Each of these orders and their bounds are used to compile the spectrum. Higher wavelength means higher px nr (right on image) and lower order nr (up on image).\
For **v2**, **Calibrator** will read `"_Vertical_points.csv"` as bounds data (has to exist). **Calibrator v3** doesn't require `"_Vertical_points.csv"`, since the underlying bounds data is constant and included in the code.\
The bounds data defines horizontally (x-value) between which pixels the order is considered. Also, it defines which are the associated wavelengths of each pixel. The px => wl conversion is quadratic function (almost linear but linear might produce up to 0.4 nm errors for low order nrs). That is why it needs 3 datapoints (px and wavelength) and why `aif` file inside `.aryx` file isn't that useful.

**Calibrator** will calculate the wavelengths and intensities of the spectrum from the diffraction orders, between the pre-defined bounds. Wavelengths are quadratic function of the horizontal pixel index. I there's only two points (e.g. in **v2**) then linear function is used with close but not precise wavelengths.\
The intensity is the integral (sum) of pixel values vertically, so that the integral is from half way between current and top order until half way between current and bottom order. E.g. the currect pixel is at coordinates `(x,y = 550, 256)` and the top order is at `y = 250` and the bottom order is at `y = 260`. Then the integral is at `x = 550` from `y = 253` to `y = 258`. In the future, I might do interpolation and precise integral (instead of summing pixels) and enable Gaussian weights (center px has higher weight than distant px).


**Calibration data:**
The calibration data is in `.json` format, so that it could be read and edited externally. E.g. you can change `first_order_nr` or `total_shift_right` or `total_shift_up` in the file.\
The bulk of calibration data consists of `dynamic` and `static` part. Static part represents the bounds data (order nr, px bounds, wavelengths). Dynamic part represents drawn curves and their points. It's "dynamic", because reordering the curves will change the order numbers (orders are always sorted low to high from top to bottom on the image).\
By default, topmost drawn order is assigned the smallest order number in static data. E.g. for 6th curve (index 5) the order nr is 6th dictionary in static data (e.g. order nr 40 if first one in static data is 35). \
If the bounds data has more orders defined than actual orders drawn then the last drawn orders get larger order numbers but data is copied from last existing order in bounds data.\
If the topmost drawn order has larger actual order number than the smallest order number in bounds data, then you must write the actual order number (`self.first_order_nr`) as `"Overwrite first order nr:"` in input field on the left pane. Then the topmost curve gets linked with the static list element that has `order_nr == self.first_order_nr` (effectively offsets dynamic vs static lists).

If an order is associated with static data which has `use_order == False`, then the curve is gray. These points will be shown in the spectrum with **Calibrator**, but **Processor** will exclude these orders from the ouput spectrum.\
Gray orders are the ones that are too close to the image edge. Integrating pixel intensity would give lower value than it actually is. Since we don't have W calibration lamp data for most days then spectral sensitivity can't account for the missing intensity when there has been a shift for the current echellogram relative to the W lamp image.\
Toggling `"Ignore orders near top edge"` button will enable/disable this feature, so if ignore is `False` then for all orders `use_order == True` and **Processor** will include these orders.


I arbitrarily defined aligned sample 492 as vertical zero-shift because it had spectral lines in multiple spectral regions and was relatively clean sample.\
Horizontal zero-shift is with the original bounds data (included in code for **v3**). Sample 492 is horizontally aligned with shift 7.35. 

Orders are essentially aligned with the "perfect" Hg lamp image that's saved internally in Sophi nXt. The actual Hg lamp image which we saved has shifted related to the orders (shift in image is same as shift in orders in opposite direction) and the actual experiment series have shifted from our lamp image. The "perfect" image is inaccessible, thus requiring **Calibrator** to recreate the internal matrix (diffraction order curves and their shapes).

**Things to consider with vertical shift:**
- shift doesn't change wavelengths but changes line intensity vs ghost line intensity in output spectrum.
- shift can push an order too close to the top edge. In that case, Sophi nXt might remove the order from the spectrum. Also, my program doesn't have value mirroring, so the intensity will be lower if order is too close to the top edge, and usually spectral sensitivity from W lamp can't account for it.

**Things to consider with horizontal shift:**
- wavelengths change. The wavelengths are locked to the orders (the "perfect" Hg image). When moving orders to the right, the output spectrum wavelengths shift to the left.
- the shift is sensitive to the order shape. If the order has shifted far then the intensities change due to the downward slope of an order (spectral line below the order might now be on top of the order), in extreme case the spectral line might appear in next order (unlikely to have such a shift).


**PS.** **Processor** works like **Calibrator** but is dumbed-down. It doesn't have GUI and the respective elements and will only take calibration data as input. **Processor** processes all the echellograms in the folder without averaging anything. Essentially it replaces Sophi nXt after the camera has registered the light and before the spectrum is written to pc. Note that **Processor** can also take `"_Spectra_multipliers.csv"` as input to skip spectral sensitivity correction later (sensitivity correction is currently broken and unused).

---

## Other notes
- Manual calibration takes 5-10 min for me with pre-existing calibration file.
- After calibration, **Processor** processes 1 image to spectrum in 0.25 s (v2.0).
- Other days in the JET experiments can take calibration day Echellogram calibration data as inputs for the program.
- Pixel bounds are constant but wavelengths shift with horizontal shift (different wavelengths for different series).
- Orders 40-41 have sudden change in amount of px in order (and location of bounds). This comes from Sophi nXt. I don't know why they did it but my program has nothing else to use.

---

## What inputs/buttons do (left pane)

### **"Dangerous" Buttons in the GUI:**

- **Save calibration data**: Overwrites the calibration data (used also as input during next restart).
- **Output stuff**: Overwrites previously output files if not backed up. 

Otherwise don't be afraid to press the buttons and test what they do.

### Input fields
- **Use sample** – you can change the automatically chosen sample but you have to input the exact filename. Also the input must be the one with `_0001` index. The hardcoding is necessary because the naming convention in JET failed (many different formats).
- **Directory path** – you can change working directory but it might be easier to simply move `.py` and input files.
- **Average photos target** – how many echellograms to average starting from first index. If there aren't enough echellograms in the series then the existing amount is used instead.
- **Overwrite first order nr** – if the actual order nr of the topmost drawn order is different than the smallest order nr defined in bounds data, then this setting defines which order nr is given to the topmost diffraction order. This setting is important when compiling spectrum and exporting calibration data.
- **Shift orders up** – moves all orders and bounds up on the image (same as moving image in opposite direction). These inputs shift all orders simultaneously and accept negative values. Shifting orders is the main part (only part (?)) of calibration if you have a previous calibration data file. Vertical shift influences spectrum pixel intensities and ghost lines.
- **Shift orders right** – moves all orders and bounds right on the image (same as moving image in opposite direction). These inputs shift all orders simultaneously and accept negative values. Shifting orders is the main part (only part (?)) of calibration if you have a previous calibration data file. Horizontal shift influences spectrum pixel wavelengths and the diffraction orders' shapes (vs bright lines on actual data) need to be checked.
- **Save variables button** – registers all written inputs simultaneously
- **Reset shifts button** - moves orders back, so they would have shifts defined in the input calibration data file.
- **Program log** shows feedback when you press a button.

### Important main buttons
- **Try automatic calibration** (!!) Currently poorly implemented (!!) – Tries to shift the orders to find the optimal configuration. It’s a bit slow and isn’t foolproof. You have to visually confirm the result!
- **Save calibration data** – this button overwrites the calibration data `.json` file and is the whole reason the program exists. Be sure to make backups of the file!
- **Toggle ignore orders near top edge** - if the order is too close the the top edge of the image then the order gets `use_order = False` in calibration data. Then **Processor**-output spectrum excludes that order.
- **Toggle shift also curve shape** (**"Only shift bounds right (vs curves)"** in reality) - whether to change diffraction order curves on the spectrum when shifting orders horizontally. If `True` (default) then upon horizontal shift, the order bounds (black crosses) are shifted but the order curves stay where they are. Otherwise the curves shift too (the three points which make a curve shift). Only change this if you understand what you're doing (!). No matter the shifts and settings, the curves need to match with the bright lines on the image (actual light output).

### Program control buttons
- **Reset program mode** – disarms callbacks. You can always press this safely. E.g. disarms edit mode.
- **Select/deselect order mode** – arms/disarms the select mode: clicking on the plot selects/deselects the order which has the closest point to the click location.
- **Diffr order edit mode (armed)** – arms/disarms the edit mode: if an order is selected then clicking with edit mode moves the closest point of the selected order to the location of the click. This can be used to change the shape or location of individual orders. There is no undo button (!), you can only restart the program with previous calibration data.
- **Add diffr order** – if old calibration file doesn’t have enough orders or you’re building one from scratch then this adds another order with 3 points to the top of the image. The added order is automatically selected.
- **Delete diffr order** – Deletes the selected order. 

**Comment:** Moving/adding/deleting order sorts orders by average y-value. If an order is moved higher than another then it inherits the corresponding order number and corresponding bounds and wavelengths. 

### Miscallenous buttons
- **Toggle spectrum updating (speed)** – updating spectrum after every order point move is slow. You can disable updating, move many points, enable updating and move last thing to fire the code that redraws the spectrum.
- **Load order points (file)** – you can input order points with another file instead of editing everything manually.
- **Output stuff (files)** – Outputs stuff like the spectrum, quadratic polynomial coefficients for every order, order points for Excel use etc.
- **Tidy order points** – Puts order points at same x-value (3 points per order = 3 values). The corresponding y-coordinate is calculated with the polynomial.
- **Toggle shift spectrum wavelengths** – whether to change wavelengths on the spectrum when shifting orders horizontally. If `True` (default) then wavelengths are locked to order curves, otherwise they don’t change and are locked to Echellogram pixels. Only change this if you understand what you're doing (!).

### Visual options
- **Toggle showing orders** – Hides/unhides diffraction orders and bounds. Useful for viewing the spots (spectral lines) or bright horizontal lines on the Echellogram.
- **Toggle spectrum log scale** – linear vs log y-scale on the spectrum.
- **Toggle autoupdate spectrum scale** – editing orders resizes spectrum. If autoupdate is disabled then you can lock a zoomed view in place while moving the orders (line might shift out of view but otherwise very useful).
- **Colorbar bounds (4 buttons)** – Manipulating these you can better view certain locations on Echellogram. E.g. raise colorbar min increases contrast between bright horizontal lines and background.

---

## TODO

- Spectral multipliers for processor
- Fix autocalibration
- remove shift wavelengths button, so user can't mess things up?
- clip x-values (and corresponding bounds) in case shift is so large that pixel is out of bounds
- draw integration radius around selected order (radius depends on distance of orders - causes confusion in GUI)
- Avg_y calc with curve data, not three points - more accurate
- Top edge value mirroring when integrating an order close to the edge?
- self.orders_x_pixels int vs float